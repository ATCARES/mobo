<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - lib\model\buildGraph.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>lib\model\buildGraph.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">38.28</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">538</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">45.91</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.96</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">//////////////////////////////////////////
// Requirements                         //
//////////////////////////////////////////

var fs     = require(&#039;fs-extra&#039;);

var logger = require(&#039;../logger.js&#039;);
var log    = logger.log;

/**
 * 1)   Builds a graph model from the current development data model
 *      This takes the relationships between the fields, models and forms into account.
 *      The resulting graph will be exported as a .json and a .gexf (Gephi) file.
 *      The .gefx file needs further layouting to be ready for viewing in the interactive graph browser!
 *
 * 2)   Validates the model for consistency
 *      This takes the relationships into account and will throw warnings if inconsistencies are detected
 *
 * @param settings
 * @param registry
 */
exports.exec = function(settings, registry) {

    //////////////////////////////////////////
    // Variables                            //
    //////////////////////////////////////////

    var nodes       = {};
    var edges       = {};

    var nodeCounter = 0;
    var edgeCounter = 0;

    var escape      = exports.escape;

    var field;
    var model;

    var node;
    var edge;
    var edgeId;

    var modelSiteName;
    var targetSiteName;
    var fieldSiteName;


    //////////////////////////////////////////
    // Iterate Fields                       //
    //////////////////////////////////////////

    for (var fieldName in registry.field) {

        // Create DataType Nodes
        field = registry.field[fieldName];
        fieldSiteName = &#039;property:&#039; + fieldName;

        var type, format;

        if (field.items) {
            field.multiple = true;
        }

        if (field.type) {
            type = field.type;
        } else if (field.items &amp;&amp; field.items.type) {
            type = field.items.type;
        } else {
            type = false;
        }

        if (field.format) {
            format = field.format;
        } else if (field.items &amp;&amp; field.items.format) {
            format = field.items.format;

        } else {
            format = false;
        }

        // Validation
        if (!type) {
            log(&#039;&gt; [WARNING] &#039; + fieldSiteName + &#039;:: No Field Type!&#039;);
            if (settings.verbose) {
                log(field);
            }
        }

        if (format &amp;&amp; format.charAt(0) === &#039;/&#039;) {

            // Calculate and write field target
            field.target = exports.getIdByRef(format);

        } else if (field.items &amp;&amp; (field.items.anyOf || field.items.allOf)) {

            // Do not create a node for this field, since it is only referencing to other nodes

        } else {

            var typeName = type;

            if (format) {
                typeName += &#039;-&#039; + format;
            }

            if (!field.title) {
                log(&#039;&gt; [WARNING] Field &#039; + fieldName + &#039; has no title!&#039;);
            }

            nodes[fieldSiteName.toLowerCase()] = {
                id: fieldSiteName,
                label: fieldSiteName,
                niceLabel: field.title || fieldSiteName,
                description: field.description || &#039;&#039;,
                type: typeName,
                size: settings.buildGraphSettings.dataTypeNodeSize
            };

            nodeCounter += 1;

            field.target = fieldName;

        }
    }

    //////////////////////////////////////////
    // Iterate Models                       //
    //////////////////////////////////////////

    // Iterate Models to create Model Nodes
    for (var modelName in registry.expandedModel) {

        model = registry.expandedModel[modelName];
        modelSiteName = &#039;template:&#039; + modelName;

        nodes[modelSiteName.toLowerCase()] = {
            id: modelSiteName,
            label: modelSiteName,
            niceLabel: model.title || modelSiteName,
            description: model.description || &#039;&#039;,
            type: &quot;Model&quot;,
            size: settings.buildGraphSettings.modelNodeSize
        };

        if (model.smw_subobject) {
            nodes[modelSiteName.toLowerCase()].type = &#039;SubObject&#039;;
        }

        nodeCounter += 1;

    }

    // Iterate Models to generate edges, depending on the fields used
    for (modelName in registry.expandedModel) {

        model = registry.expandedModel[modelName];
        modelSiteName = &#039;template:&#039; + modelName;

        for (var propertyName in model.properties) {

            var property = model.properties[propertyName];
            fieldName = exports.getIdByRef(property.$reference);
            fieldSiteName = &#039;property:&#039; + fieldName;
            field = registry.field[fieldName];

            if (!field) {
                // Field missing completely
                log(&#039;&gt; [WARNING] Model &quot;&#039; + modelSiteName + &#039;&quot; is missing its field &quot;&#039; + fieldSiteName + &#039;&quot;!&#039;);
                if (settings.verbose) {log(model);}

            } else {

                // Check if Model references to multiple other Models
                var anyArray = false;

                if (field.items &amp;&amp; (field.items.anyOf || field.items.allOf)) {
                    if (field.items.anyOf) {
                        anyArray = field.items.anyOf;
                    } else {
                        anyArray = field.items.allOf;
                    }
                }

                // anyOf || allOf
                if (anyArray) {

                    for (var i = 0; i &lt; anyArray.length; i++) {

                        var attr = anyArray[i];
                        var target = exports.getIdByRef(attr.format);
                        targetSiteName = &#039;template:&#039; + target;
                        edgeId = modelSiteName + &#039;-&#039; + targetSiteName;

                        if (!edges[edgeId.toLowerCase()]) {
                            edges[edgeId.toLowerCase()] = {
                                id: edgeId,
                                undirectedId: field.id,
                                label: field.title,
                                source: modelSiteName,
                                target: targetSiteName,
                                weight: settings.buildGraphSettings.edgeWeight
                            };

                            if (field.items) {
                                edges[edgeId.toLowerCase()].weight = settings.buildGraphSettings.multipleEdgeWeight;
                            }

                            edgeCounter += 1;
                        }
                    }

                } else if (nodes[modelSiteName.toLowerCase()]) {

                    // Checks if first char is uppercase. If it is, it references to a Template
                    // If not, it references to an attribute (which is represented as a helper node)
                    if (field.target[0] === field.target[0].toUpperCase()) {
                        targetSiteName = &#039;template:&#039; + field.target;
                    } else {
                        targetSiteName = &#039;property:&#039; + field.target;
                    }

                    edgeId = modelSiteName + &#039;-&#039; + targetSiteName;

                    if (!edges[edgeId.toLowerCase()]) {
                        edges[edgeId.toLowerCase()] = {
                            id: edgeId,
                            undirectedId: field.id,
                            label: field.title,
                            source: modelSiteName,
                            target: targetSiteName,
                            weight: settings.buildGraphSettings.edgeWeight
                        };

                        if (field.items) {
                            edges[edgeId.toLowerCase()].weight = settings.buildGraphSettings.multipleEdgeWeight;
                        }

                        edgeCounter += 1;
                    }

                } else {
                    log(&#039;&gt; [WARNING] Field &quot;&#039; + fieldSiteName + &#039;&quot; has missing node &quot;&#039; + modelSiteName + &#039;&quot;!&#039;);
                    if (settings.verbose) {log(field);}
                }
            }
        }
    }

    //////////////////////////////////////////
    // Iterate Custom Templates             //
    //////////////////////////////////////////

    // Iterate Models to create Model Nodes
    for (var templateName in registry.smw_template) {

        var templateSiteName = &#039;template:&#039; + templateName.replace(&#039;.wikitext&#039;, &#039;&#039;);

        if (!nodes[templateSiteName.toLowerCase()]) {
            nodes[templateSiteName.toLowerCase()] = {
                id: templateSiteName,
                label: templateSiteName,
                niceLabel: templateSiteName,
                description: &#039;&#039;,
                type: &quot;Template&quot;,
                size: settings.buildGraphSettings.templateNodeSize
            };
            nodeCounter += 1;
        }

    }

    //////////////////////////////////////////
    // Iterate Forms                        //
    //////////////////////////////////////////

    for (var formName in registry.expandedForm) {

        var form = registry.expandedForm[formName];
        var formSiteName = &#039;form:&#039; + formName;

        nodes[formSiteName.toLowerCase()] = {
            id: formSiteName,
            label: formSiteName,
            niceLabel: form.title || formSiteName,
            description: form.description || &#039;&#039;,
            type: &quot;Form&quot;,
            size: settings.buildGraphSettings.formNodeSize
        };

        nodeCounter += 1;

        var models = form.properties || form.items.properties;

        if (models) {

            for (modelName in models) {

                model = models[modelName];

                if (model) {
                    var modelId = model.id || modelName;

                    modelSiteName = &#039;template:&#039; + modelId;

                    if (modelId) {
                        edgeId = formSiteName + &#039;-&#039; + modelName;

                        // Ignore wikitext attributes, since they are directly written into the form template
                        if (!edges[edgeId.toLowerCase()] &amp;&amp; !model.wikitext) {
                            edges[edgeId.toLowerCase()] = {
                                id: edgeId,
                                undirectedId: &#039;smwTemplate&#039;,
                                label: &#039;smwTemplate&#039;,
                                source: formSiteName,
                                target: modelSiteName,
                                weight: settings.buildGraphSettings.edgeWeight
                            };
                            edgeCounter += 1;
                        }
                    } else {
                        log(&#039;&gt; [WARNING] Form &quot;&#039; + formSiteName + &#039;&quot; has missing template &quot;&#039; + modelSiteName + &#039;&quot;!&#039;);
                        if (settings.verbose) {log(form);}
                    }
                } else {
                    log(&#039;&gt; [WARNING] Form &quot;&#039; + formSiteName + &#039;&quot; has missing model &quot;&#039; + modelName + &#039;&quot;!&#039;);
                    if (settings.verbose) {log(form);}
                }
            }

        } else {
            log(&#039;&gt; [WARNING] Form &quot;&#039; + formSiteName + &#039;&quot; has no properties!&#039;);
            if (settings.verbose) {log(form);}
        }

    }

    //////////////////////////////////////////
    // More Validation                      //
    //////////////////////////////////////////

    for (var nodeName in nodes) {

        node = nodes[nodeName.toLowerCase()];

        // Apply Color to Node
        node.color = exports.getColor(node.type);

        var hasConnections = exports.checkForConnections(node, edges);

        if (!hasConnections) {

            if (nodeName.indexOf(&quot;template:&quot;) &gt; -1) {
                if (settings.verbose) {
                    log(&#039;&gt; [NOTICE] Template-Node &quot;&#039; + nodeName + &#039;&quot; has no connections!&#039;);
                    log(node);
                }
            } else {
                log(&#039;&gt; [WARNING] Node &quot;&#039; + nodeName + &#039;&quot; has no connections!&#039;);
                if (settings.verbose) {log(node);}
            }

        }

    }

    // Checks if the edges source and target nodes exist
    for (var edgeName in edges) {
        edge = edges[edgeName.toLowerCase()];

        if (!nodes[edge.source.toLowerCase()]) {
            log(&#039;&gt; [WARNING] Edge &quot;&#039; + edgeName + &#039;&quot; is missing its source node &quot;&#039; + edge.source + &#039;&quot;&#039;);
        }

        if (!nodes[edge.target.toLowerCase()]) {
            log(&#039;&gt; [WARNING] Edge &quot;&#039; + edgeName + &#039;&quot; is missing its target node &quot;&#039; + edge.target + &#039;&quot;&#039;);
        }
    }

    //////////////////////////////////////////
    // Export: Header                       //
    //////////////////////////////////////////

    var gefxExport = &#039;\ufeff&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&#039;;
    gefxExport    += &#039;&lt;gexf xmlns=&quot;http://www.gexf.net/1.2draft&quot; version=&quot;1.2&quot; xmlns:viz=&quot;http://www.gexf.net/1.2draft/viz&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.gexf.net/1.2draft http://www.gexf.net/1.2draft/gexf.xsd&quot;&gt;\n&#039;;
    gefxExport    += &#039;  &lt;meta lastmodifieddate=&quot;2014-06-04&quot;&gt;\n&#039;;
    gefxExport    += &#039;      &lt;creator&gt;Simon Heimler&lt;/creator&gt;\n&#039;;
    gefxExport    += &#039;      &lt;description&gt;CB Model Graph&lt;/description&gt;\n&#039;;
    gefxExport    += &#039;  &lt;/meta&gt;\n&#039;;
    gefxExport    += &#039;  &lt;graph mode=&quot;static&quot; defaultedgetype=&quot;directed&quot;&gt;\n&#039;;
    gefxExport    += &#039;      &lt;attributes class=&quot;node&quot;&gt;\n&#039;;
    gefxExport    += &#039;          &lt;attribute id=&quot;type&quot; title=&quot;Type&quot; type=&quot;string&quot;/&gt;\n&#039;;
    gefxExport    += &#039;          &lt;attribute id=&quot;size&quot; title=&quot;Size&quot; type=&quot;integer&quot;/&gt;\n&#039;;
    gefxExport    += &#039;          &lt;attribute id=&quot;nicelabel&quot; title=&quot;Nice Label&quot; type=&quot;string&quot;/&gt;\n&#039;;
    gefxExport    += &#039;          &lt;attribute id=&quot;description&quot; title=&quot;Description&quot; type=&quot;string&quot;/&gt;\n&#039;;
    gefxExport    += &#039;      &lt;/attributes&gt;\n&#039;;
    gefxExport    += &#039;      &lt;attributes class=&quot;edge&quot;&gt;\n&#039;;
    gefxExport    += &#039;          &lt;attribute id=&quot;undirectedId&quot; title=&quot;Undirected ID&quot; type=&quot;string&quot;/&gt;\n&#039;;
    gefxExport    += &#039;      &lt;/attributes&gt;\n&#039;;


    //////////////////////////////////////////
    // Export: Nodes                        //
    //////////////////////////////////////////

    gefxExport    += &#039;      &lt;nodes&gt;\n&#039;;

    for (var nodeId in nodes) {
        node = nodes[nodeId];
        gefxExport    += &#039;          &lt;node id=&quot;&#039; + node.id + &#039;&quot; label=&quot;&#039; + escape(node.label) + &#039;&quot;&gt;\n&#039;;
        gefxExport    += &#039;              &lt;attvalues&gt;\n&#039;;
        gefxExport    += &#039;                  &lt;attvalue for=&quot;type&quot; value=&quot;&#039; + node.type + &#039;&quot;/&gt;\n&#039;;
        gefxExport    += &#039;                  &lt;attvalue for=&quot;size&quot; value=&quot;&#039; + node.size + &#039;&quot;/&gt;\n&#039;;
        gefxExport    += &#039;                  &lt;attvalue for=&quot;nicelabel&quot; value=&quot;&#039; + escape(node.niceLabel) + &#039;&quot;/&gt;\n&#039;;
        gefxExport    += &#039;                  &lt;attvalue for=&quot;description&quot; value=&quot;&#039; +escape( node.description) + &#039;&quot;/&gt;\n&#039;;
        gefxExport    += &#039;              &lt;/attvalues&gt;\n&#039;;
        gefxExport    += &#039;              &lt;viz:size value=&quot;&#039; + node.size + &#039;&quot;&gt;&lt;/viz:size&gt;\n&#039;;
        gefxExport    += &#039;              &lt;viz:color &#039; + node.color + &#039;&gt;&lt;/viz:color&gt;\n&#039;;
        gefxExport    += &#039;          &lt;/node&gt;\n&#039;;
    }
    gefxExport    += &#039;      &lt;/nodes&gt;\n&#039;;

    //////////////////////////////////////////
    // Export: Edges                        //
    //////////////////////////////////////////

    gefxExport    += &#039;      &lt;edges&gt;\n&#039;;
    for (edgeId in edges) {
        edge = edges[edgeId];
        gefxExport    += &#039;          &lt;edge id=&quot;&#039; + edge.id + &#039;&quot; label=&quot;&#039; + edge.label + &#039;&quot; source=&quot;&#039; + edge.source + &#039;&quot; target=&quot;&#039; + edge.target + &#039;&quot; weight=&quot;&#039; + edge.weight + &#039;&quot;&gt;\n&#039;;
        gefxExport    += &#039;              &lt;attvalues&gt;\n&#039;;
        gefxExport    += &#039;                  &lt;attvalue for=&quot;undirectedId&quot; value=&quot;&#039; + edge.undirectedId + &#039;&quot;/&gt;\n&#039;;
        gefxExport    += &#039;              &lt;/attvalues&gt;\n&#039;;
        gefxExport    += &#039;          &lt;/edge&gt;\n&#039;;
    }
    gefxExport    += &#039;      &lt;/edges&gt;\n&#039;;


    //////////////////////////////////////////
    // Export: Footer                       //
    //////////////////////////////////////////

    gefxExport    += &#039;  &lt;/graph&gt;\n&#039;;
    gefxExport    += &#039;&lt;/gexf&gt;\n&#039;;


    //////////////////////////////////////////
    // JSON Graph Export                    //
    //////////////////////////////////////////

    var jsonGraph = {
        nodes: nodes,
        edges: edges
    };

    fs.outputFile(settings.processedModelDir + &#039;_graph.gexf&#039;, gefxExport);
    fs.outputFile(settings.processedModelDir + &#039;_graph.json&#039;, JSON.stringify(jsonGraph, false, 4));

    log(&#039;&gt; &#039; + nodeCounter + &#039; Nodes | &#039; + edgeCounter + &#039; Edges&#039;);
    log(&#039;-------------------------------------------------------------------------&#039;);

};

//////////////////////////////////////////
// HELPER FUNCTIONS                     //
//////////////////////////////////////////

/**
 * Takes an model/field/form $extend URL and returns the name of the file without extension
 *
 * @param url
 * @returns {string}
 */
exports.getIdByRef = function(url) {
    var ref = url.split(&#039;/&#039;);
    return ref[2].replace(&#039;.json&#039;, &#039;&#039;);
};

/**
 * Escapes certain characters for the XML output
 *
 * @param string
 * @returns {string}    escaped string
 */
exports.escape = function(string) {

    if (string) {
        string = string.replace(&#039;&amp;&#039;, &#039;&amp;amp;&#039;);

        return string;
    } else {
        return false;
    }
};

/**
 * Colors the node depending on their function
 *
 * @param type
 * @returns {string}
 */
exports.getColor = function(type) {
    if (type === &#039;Form&#039;) {
        return &#039;r=&quot;73&quot; g=&quot;199&quot; b=&quot;232&quot;&#039;;
    } else if (type === &#039;Model&#039;) {
        return &#039;r=&quot;168&quot; g=&quot;242&quot; b=&quot;53&quot;&#039;;
    } else if (type === &#039;SubObject&#039;) {
        return &#039;r=&quot;226&quot; g=&quot;242&quot; b=&quot;87&quot;&#039;;
    } else if (type === &#039;Template&#039;) {
        return &#039;r=&quot;250&quot; g=&quot;189&quot; b=&quot;43&quot;&#039;;
    } else if (type === &#039;array&#039;) {
        return &#039;r=&quot;125&quot; g=&quot;235&quot; b=&quot;143&quot;&#039;;
    } else if (type === &#039;number&#039;) {
        return &#039;r=&quot;209&quot; g=&quot;110&quot; b=&quot;244&quot;&#039;;
    } else if (type.indexOf(&quot;string&quot;) &gt; -1) {
        return &#039;r=&quot;149&quot; g=&quot;91&quot; b=&quot;244&quot;&#039;;
    } else if (type === &#039;boolean&#039;) {
        return &#039;r=&quot;244&quot; g=&quot;91&quot; b=&quot;91&quot;&#039;;
    } else {
        return &#039;r=&quot;165&quot; g=&quot;165&quot; b=&quot;165&quot;&#039;;
    }
};

/**
 * Checks if a node has Connections to other nodes
 *
 * If not, it is an orphan and should be adressed
 *
 * @param node
 * @returns {boolean}
 */
exports.checkForConnections = function(node, edges) {

    for (var edgeName in edges) {
        var edge = edges[edgeName.toLowerCase()];

        if (edge.source === node.id || edge.target === node.id) {
            return true;
        }
    }

    return false;
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
